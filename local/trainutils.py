#AUTOGENERATED! DO NOT EDIT! File to edit: dev/3a) trainutils.ipynb (unless otherwise specified).

__all__ = ['bce', 'dice_loss', 'FocalLoss', 'MixedLoss', 'loss_dict', 'my_cond_init', 'bn_types', 'gnorm_types',
           'insnorm_types', 'norm_types', 'dice_score']

#Cell
from fastai2.vision.all import *
from fastai2.torch_imports import *
from fastai2.torch_core import *
# from fastai.callbacks import *

#Cell
# def dice_loss(logits, target, smooth=1.):
#     if torch.any(torch.isnan(logits)): print("logits contain nan")
#     probas = torch.sigmoid(logits)
#     if torch.any(torch.isnan(probas)): print("probas contain nan")
#     iflat = probas.view(-1)
#     tflat = target.view(-1)
#     intersection = (iflat * tflat).sum()
#     return 1 - ((2.0 * intersection + smooth) / (iflat.sum() + tflat.sum() + smooth))

def bce(input, target):
    bs = input.shape[0]
    return F.binary_cross_entropy_with_logits(input.view(bs,-1).float(), target.view(bs,-1).float())

def dice_loss(logits, target, smooth=1.):
    logits = torch.sigmoid(logits)
    iflat = logits.view(-1)
    tflat = target.view(-1)
    intersection = (iflat * tflat).sum()
    return 1 - ((2.0 * intersection + smooth) / (iflat.sum() + tflat.sum() + smooth))

class FocalLoss(nn.Module):
    def __init__(self, gamma):
        super().__init__()
        self.gamma = gamma

    def forward(self, logits, target):
        logits = logits.squeeze(1)
        if not (target.size() == logits.size()):
            raise ValueError("Target size ({}) must be the same as input size ({})"
                             .format(target.size(), logits.size()))

        max_val = (-logits).clamp(min=0)
        loss = logits - logits * target + max_val + \
            ((-max_val).exp() + (-logits - max_val).exp()).log()

        invprobs = F.logsigmoid(-logits * (target * 2.0 - 1.0))
        loss = (invprobs * self.gamma).exp() * loss

        return loss.mean()

class MixedLoss(nn.Module):
    def __init__(self, alpha, gamma):
        super().__init__()
        self.alpha = alpha
        self.focal = FocalLoss(gamma)

    def forward(self, input, target):
        loss = self.alpha*self.focal(input, target) - torch.log(1 - dice_loss(input, target))
        return loss.mean()


#Cell
from fastai2.layers import *
loss_dict = {'dice':dice_loss, 'bce':BCEWithLogitsLossFlat(), 'mixed':MixedLoss(10., 2.)}

#Cell
bn_types = (nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d)
gnorm_types = (nn.GroupNorm,)
insnorm_types = (nn.InstanceNorm1d, nn.InstanceNorm2d, nn.InstanceNorm3d)
norm_types = bn_types + gnorm_types + insnorm_types

def my_cond_init(m,func):
    "Initialize the non-batchnorm and PRelu layers of `m` with `init_func`."
    if (not isinstance(m, (*norm_types, nn.PReLU))) and requires_grad(m): init_default(m, func)

#Cell
#metrics
# def get_img_pred_masks(learner, dl, thresh=0.5):
#     model = learner.model.eval()
#     preds = []
#     images = []
#     masks = []
#     for image, mask in tqdm_notebook(dl):
#         out = model(image.half().cuda())
#         out = torch.sigmoid(out).cpu().data.numpy()
#         out = out.astype(float)
#         out = (out > thresh)*1
#         image = image.cpu().data.numpy()
#         mask = mask.cpu().data.numpy()
#         for i in range(out.shape[0]):
#             masks.append(mask[i])
#             preds.append(out[i][0])
#             images.append(image[i][0])
#     return images, preds, masks

# def plot_predictions(true, pred, mask):
#     """draw image, pred, mask side by side"""
#     fig, ax = plt.subplots(1,3, figsize=(20,10))
#     axes = ax.flatten()
#     for ax, im, t in zip(axes, [true, pred, mask], ["image", "pred", "mask"]) :
#         ax.imshow(im, cmap="gray")
#         ax.set_title(t, fontdict={"fontsize":20})

def dice_score(logits, targets, thresh=0.5):
    hard_preds = torch.sigmoid(logits) > thresh
    m1 = hard_preds.view(-1).float()
    m2 = targets.view(-1).float()
    intersection = (m1 * m2).sum()
    return (2. * intersection) / (m1.sum() + m2.sum() + 1e-6)

# def eval_preds(preds, target, thresh=0.5):
#     iflat = np.array(preds).reshape(-1)
#     tflat = np.array(target).reshape(-1)
#     intersection = (iflat * tflat).sum()
#     return ((2.0 * intersection) / (iflat.sum() + tflat.sum() + 1e-6))